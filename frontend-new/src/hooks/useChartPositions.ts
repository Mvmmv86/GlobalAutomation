import { useMemo, useEffect } from 'react'
import { useActivePositions, useBalancesSummary } from './useApiData'
import { usePositionOrders } from './usePositionOrders'

export interface ChartPosition {
  id: string
  symbol: string
  side: 'LONG' | 'SHORT'
  entryPrice: number
  quantity: number
  markPrice?: number
  unrealizedPnl?: number
  stopLoss?: number
  takeProfit?: number
  allTakeProfits?: number[] // MÃºltiplos TPs
  liquidationPrice?: number
  leverage?: number
  margin?: number
  status: 'open' | 'closing'
}

interface UseChartPositionsParams {
  symbol: string
  exchangeAccountId?: string
}

/**
 * Hook para gerenciar posiÃ§Ãµes especÃ­ficas do sÃ­mbolo atual no grÃ¡fico
 * Filtra apenas posiÃ§Ãµes abertas do sÃ­mbolo selecionado
 */
export const useChartPositions = ({ symbol, exchangeAccountId }: UseChartPositionsParams) => {
  // FALLBACK: Usar dados do dashboard quando endpoint /positions/active estÃ¡ quebrado
  const {
    data: dashboardData,
    isLoading: isDashboardLoading,
    error: dashboardError
  } = useBalancesSummary()

  // Buscar posiÃ§Ãµes abertas da conta selecionada (endpoint que pode estar quebrado)
  const {
    data: openPositions = [],
    isLoading,
    error
  } = useActivePositions({
    ...(exchangeAccountId && { exchangeAccountId }),
    operationType: 'futures' // Apenas FUTURES tÃªm SL/TP
  })

  // Buscar ordens de SL/TP para o sÃ­mbolo
  const {
    data: ordersData,
    isLoading: isLoadingOrders
  } = usePositionOrders(exchangeAccountId, symbol)

  // DEBUG: Log sempre que exchangeAccountId ou openPositions mudarem
  useEffect(() => {
    console.log('ðŸ” useChartPositions DEBUG:', {
      exchangeAccountId,
      openPositionsCount: openPositions.length,
      hasError: !!error,
      isLoading,
      openPositions: openPositions.map(p => ({ symbol: p.symbol, side: p.side }))
    })
  }, [exchangeAccountId, openPositions, error, isLoading])

  // Filtrar e processar posiÃ§Ãµes do sÃ­mbolo atual
  const chartPositions = useMemo((): ChartPosition[] => {
    if (!symbol) {
      console.log('âš ï¸ useChartPositions: SÃ­mbolo vazio, retornando []')
      return []
    }

    console.log('ðŸŽ¯ useChartPositions: Filtrando posiÃ§Ãµes para sÃ­mbolo', symbol)
    console.log('ðŸ“Š Total de posiÃ§Ãµes recebidas:', openPositions.length)

    // Tentar usar dados do endpoint specific primeiro, fallback para dashboard
    let positionsToUse = openPositions

    // Se endpoint especÃ­fico nÃ£o funciona, usar posiÃ§Ãµes do dashboard
    if ((!openPositions || openPositions.length === 0 || error) && dashboardData?.positions) {
      console.log('ðŸ“Š Usando posiÃ§Ãµes do dashboard como fallback')
      positionsToUse = dashboardData.positions
    } else {
      console.log('ðŸ“Š PosiÃ§Ãµes disponÃ­veis do endpoint especÃ­fico:', openPositions.length)
    }

    if (!positionsToUse || positionsToUse.length === 0) {
      console.log('âš ï¸ Nenhuma posiÃ§Ã£o encontrada (nem endpoint nem dashboard)')
      return []
    }

    return positionsToUse
      .filter(position => {
        // Normalizar sÃ­mbolos para comparaÃ§Ã£o (remover espaÃ§os, etc.)
        const posSymbol = position.symbol?.toUpperCase().trim()
        const targetSymbol = symbol.toUpperCase().trim()

        const matches = posSymbol === targetSymbol
        if (matches) {
          console.log('âœ… PosiÃ§Ã£o encontrada para', targetSymbol, ':', position)
        }

        return matches
      })
      .map(position => {
        // Converter para formato do grÃ¡fico
        const chartPosition: ChartPosition = {
          id: position.id || `${position.symbol}-${Date.now()}`,
          symbol: position.symbol,
          side: position.side === 'LONG' ? 'LONG' : 'SHORT',
          entryPrice: Number(position.entryPrice || 0),
          quantity: Number(position.quantity || position.size || 0),
          markPrice: Number(position.markPrice || 0),
          unrealizedPnl: Number(position.unrealizedPnl || 0),
          liquidationPrice: Number(position.liquidationPrice || 0),
          leverage: Number(position.leverage || 1),
          margin: Number(position.margin || position.initialMargin || 0),
          status: position.status === 'open' ? 'open' : 'closing',

          // SL/TP das ordens ativas da exchange
          stopLoss: ordersData?.stopLoss,
          takeProfit: ordersData?.takeProfit,
          allTakeProfits: ordersData?.allTakeProfits
        }

        console.log('ðŸ“ˆ PosiÃ§Ã£o processada para grÃ¡fico:', chartPosition)
        return chartPosition
      })
  }, [symbol, openPositions, dashboardData, error, ordersData])

  // EstatÃ­sticas das posiÃ§Ãµes
  const positionsStats = useMemo(() => {
    const totalPositions = chartPositions.length
    const longPositions = chartPositions.filter(p => p.side === 'LONG').length
    const shortPositions = chartPositions.filter(p => p.side === 'SHORT').length
    const totalPnl = chartPositions.reduce((sum, p) => sum + (p.unrealizedPnl || 0), 0)
    const totalMargin = chartPositions.reduce((sum, p) => sum + (p.margin || 0), 0)

    return {
      total: totalPositions,
      long: longPositions,
      short: shortPositions,
      totalPnl,
      totalMargin,
      hasPositions: totalPositions > 0
    }
  }, [chartPositions])

  // Combinar estados de loading e error
  const combinedLoading = isLoading || isDashboardLoading
  const combinedError = error || dashboardError

  // ðŸš€ PERFORMANCE: Logs commented out to reduce overhead
  // console.log('ðŸ“Š useChartPositions stats:', positionsStats)

  return {
    positions: chartPositions,
    stats: positionsStats,
    isLoading: combinedLoading,
    error: combinedError,
    hasPositions: positionsStats.hasPositions
  }
}

export type { UseChartPositionsParams }